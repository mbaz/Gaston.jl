---
title: "Tutorial"
---

TODO:  polygons, glowing curves

Load Gaston with:
```{julia}
#| echo: false
using Gaston
```
The plots below have been rendered in a `png` terminal with the following configuration:
```{julia}
#| echo: false
Gaston.config.term = "pngcairo font ',10' size 640,480"
```
We need to specify that the plot examples below will be rendered to a document and not
a GUI window:
```{julia}
#| echo: false
Gaston.config.output = :echo
```
In addition, gnuplot's start up file is as
[described in the Introduction](index.qmd#gnuplot-startup-file).

## 2-D Plots

Let's start with a simple sine wave plot:

```{julia}
x = range(0, 0.5, length = 100)
y = sin.(2*pi*10*x)
plot(x, y)
```
Now, let us add a grid and some annotations:
```{julia}
@plot {grid, title = Q"{/:Bold A sine wave}", xlabel = Q"Time", ylabel = Q"Volts"} x y
```
Here we have used `@plot` instead of `plot`, which allows us to specify the plot settings
as a list of keyword arguments. These arguments can be stored in a "theme" using the
`@gpkw` macro:
```{julia}
#| output: false
settings = @gpkw {grid, title = Q"{/:Bold A sine wave}", xlabel = Q"Time", ylabel = Q"Volts"}
```
In addition, we have used the `Q` string macro to avoid typing single quotes; `Q"Time"` is
converted to `"'Time'"`.

Now let us change the line color and markers:
```{julia}
@plot settings x y {with = "lp", lc = Q"sea-green", pt = :ecircle, pn = -16, ps = 1.5}
```
Parameters that affect how the curve is plotted are specified *after* the data. These
can also be stored and reused, so that
```{julia}
#| output: false
plotline = @gpkw {with = "lp", lc = Q"sea-green", pt = :ecircle, pn = -16, ps = 1.5}
@plot settings x y plotline
```
would produce the exact same plot. Settings and plotline parameters can also be specified as strings;
see the [Manual](manual.qmd) for all the details. Gaston also has a number of built-in
[themes](tutorial.qmd#themes), showcased below.

A `plot` command can only generate a single curve. Use `plot!` or `@plot!` to append a curve:
```{julia}
@plot(settings,
      {title = Q"Two sinusoids", key = "columns 1", key = "box outside right top"},
      x, y,
      plotline, {title = "'sin'"})
y2 = cos.(2*pi*10*x)
@plot! x y2 {dashtype = Q".-.", lw = 2, lc = Q"orchid", title = Q"cos"}
```
Here we see how multiple settings and plotline arguments can be combined.  Note
that new settings cannot be declared in `plot!` commands; only the plotline for
the new curve can be specified.

#### Plotting functions

In the examples above, the data given to `plot` is stored in vectors. Functions
can be plotted directly, with a given range and number of samples, as follows:
```{julia}
g(x) = exp(-abs(x/5))*cos(x)  # function to plot
tt = "set title 'g = x -> exp(-abs(x/5))*cos(x))'"
plot(tt, (-10, 10, 200), g) # plot from x = -10 to 10, using 200 samples
```
Ranges can be specified in the following alternative ways:
```julia
plot(g)            # 101 samples, from -10 to 10
plot((a, b), g)    # 101 samples, from a to b
plot((a, b, c), g) # c samples, from a to b
plot(x, g)         # g.(x)
```

#### A note on side effects

Plot commands return a value of type `Gaston.Figure`. When values of this type
are displayed, Julia's display system calls gnuplot behind the scenes to
generate the actual plot. Plots are never generated as side effects the way they
are, for example, in Matlab.

This means that, for example, the following code does not display any figures:

```{.julia}
i = 1
while (i < 10)
    plot(x, i.*y)
    i += 1
end
```

nor will this code:

```{.julia}
function f(x, y)
    plot(x, y)
    println("Done.")
end
```

The easiest way to "force" a piece of code to generate a plot is to call `display` explicitly:

```{.julia}
i = 1
while (i < 10)
    plot(x, i.*y) |> display
    i += 1
end
```

Of course, values of type `Figure` can also be stored in variables and manipulated as any other
Julia value:

```{.julia}
function f(x, y)
    f = plot(x, y)
    println("Done.")
    return f
end
```

Internally, Gaston keeps references to all `Figure` values it has produced. If there are one
or more, one of them is _active_ in the sense that all subsequent `plot` and `plot!` commands
will target that figure. The active figure can be obtained with:

```{.julia}
figure()
```

and the figure `f` can be made active with:

```{.julia}
figure(f)
```

A new figure can be instantiated with the `Figure` constructor, as in `f =
Figure()`. The new figure is automatically made the active figure.

#### Multiplots

A convenient, automatic method to create multiplot figures is provided. First, instantiate
a new figure like this:

```{julia}
f = Figure(multiplot = "title 'Auto Layout'");
```
When a figure contains more than one axis, it is rendered using `set multiplot`. The `multiplot`
argument provides additional configuration. The figure `f` will be rendered using

    set multiplot title 'Auto Layout'

Then, add axes by indexing into the figure:
```{julia}
plot(f[1], x, y)           # plot x vs y in the first axis
plot(f[2], x, sinc.(10x))  # plot sinc(10x) in the second axis
```
It is possible to have empty "slots":
```{julia}
plot(f[4], x, sinc.(20x), "w lp pn 12")  # the third axis is empty
```
Note that Gaston tries to keep a square figure aspect ratio as more and more axes are included.

Add another curve to an axis using indexing:
```{julia}
plot!(f[2], x, 0.3randn(length(x)))
```

To get full control of the layout, pass the argument `autolayout = false` to `Figure`:
```{julia}
f = Figure("title 'Arbitrary multiplot layout demo'", autolayout = false)
x = randn(100)
y = randn(100)
@plot(f[1], {margins = (0.1, 0.65, 0.1, 0.65)},
      x, y,
      "w p pt '+' lc 'dark-green'")
@gpkw histogram(f[2],
                {margins = (0.7, 0.95, 0.1, 0.65), tics = false},
                y,
                {lc = Q"dark-green"}, nbins = 10, horizontal = true)
@gpkw histogram(f[3],
                {margins = (0.1, 0.65, 0.7, 0.9), boxwidth = "1 relative"},
                x,
                {lc = Q"dark-green"}, nbins = 10)
```
Note that margins can be specified as a tuple.

Let us close all figures created so far with
```{julia}
closeall()
```
This command closes all gnuplot processes started by Gaston and closes all figures. Close
figure `f` with

```{.julia}
close(f)
```

## 3-D Plots
Plotting in 3-D is similar to 2-D, except that `splot` (and `@splot`, `splot!`, `@splot!`) are used
instead of `plot`. This example shows how to plot the surface defined by function `s`:

```{julia}
x = y = -15:0.2:15
s = (x,y) -> @. sin(sqrt(x*x+y*y))/sqrt(x*x+y*y)
@splot "set title 'Sombrero'" "set hidden3d" {palette = :cool} x y s "w pm3d"
```

The palette `cool` is defined in
[ColorSchemes](https://github.com/JuliaGraphics/ColorSchemes.jl). Any
colorscheme from that package can be used simply by prepending its name with
`:`.

## Plotting in text terminals

It is often convenient to generate plots directly in the terminal. Gnuplot supports a few
different ways to do this:

* `sixelgd` uses [sixels](https://en.wikipedia.org/wiki/Sixel)) to generate plots almost
  identical to those produced by regular GUI terms:
  ![sixel](assets/sixelgd.png)
* `block` uses Unicode characters to draw a plot on the terminal:
  ![block](assets/block.png)

Note that, in all cases, Gaston must be configured for terminal output with

```{.julia}
Gaston.config.output = :echo
```

There are other text terms, such as `dumb`, but in general those produce output
of worse quality than `sixelgd` and `block`.

## Plotting with strings and dates

Besides numerical arrays and ranges, Gaston can also plot arrays of strings, as
shown in the following example:

```{julia}
x = 10*rand(10)
y = 10*rand(10)
w = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"]
plot(x, y, w, "w labels")
```

Julia's `Date` type can be plotted by converting it to strings, and using gnuplot's date support:

```{julia}
using Dates

dates = Date(2018, 1, 1):Day(1):Date(2019, 12, 31)
ta = rand(length(dates))
timefmt = "%Y-%m-%d" ## hour:minute:seconds are also available
pfmt = "%Y-%m-%d"
rot_xtics = -35
vals = 0.5*ta
tempo = string.(dates) # convert dates to strings
xmin1 = "2018-02-01"
xmax1 = "2019-04-01"

@gpkw settings = {xdata = "time",
                  timefmt = "'$(timefmt)'",
                  grid,
                  format = "x '$(pfmt)'",
                  xtics = "rotate by $(rot_xtics)",
                  tmargin = "at screen 0.96",
                  bmargin = "at screen 0.15",
                  lmargin = "at screen 0.1",
                  rmargin = "at screen 0.96",
                  xrange = "['$(xmin1)':'$(xmax1)']",
                  yrange = (-0.25, 0.75)}
plot(settings, tempo, vals, "u 1:2 w l t 'series'")
```

## Plotting using Latex

```{.julia}
s = @gpkw({ title = Q"Polynomial approximation of sin(x)",
            style = "fill transparent solid 0.6 noborder",
            xtics = (positions = [-pi, -pi/2, 0, pi/2, pi],
                     labels = [raw"$-\pi$", raw"$-\pi/2$", "0", raw"$\pi/2$", raw"$\pi$"]),
            xrange = (-3.8, 3.8),
            yrange = (-1.5, 1.5),
            key = "box opaque left horiz",
            linetype = :YlOrBr_7,
            grid = "front",
            label = "at graph 0.62,0.2 front center '$latex'" })
x = range(-2pi, 2pi, 1000)
y = sin.(x)
@plot s x y x "w filledcurve t 'n=0' lt 1"
@plot! x y x .- x.^3/6 "w filledcurve t 'n=1' lt 2"
@plot! x y x .- x.^3/6 .+ x.^5/120 "w filledcurve t 'n=2' lt 3"
@plot! x y x .- x.^3/6 .+ x.^5/120 .- x.^7/5040 "w filledcurve t 'n=3' lt 4"
@plot! x y "w l t 'sin(x)' lw 2 lc rgb 'black'"
save(term="cairolatex pdf input color dashed size 5in,3.3in", filename = "test.tex")
```

This code creates two files, `test.tex` and `test.pdf`, which can be used to
generate a final pdf plot by compiling the following script with `pdflatex`:

```{.latex}
\documentclass{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{color}

\begin{document}
\begin{figure}
\input{test.tex}
\end{figure}
\end{document}
```

The finished plot looks like this:

![cairolatex](assets/cairolatex.png)

A similar workflow can be used with other gnuplot terminals, such as `tikz`, `epslatex`, etc.

## Animations

Animations require using a terminal that support them; the `gif` or `webp`
terminals are the most popular ones (make sure your notebook supports the
`image/webp` MIME type before using it).

Creating an animation is similar to multiplotting: multiple axes are drawn on
the same figure. When using the `animate` option of the `gif` or `webp`
terminals, however, the plot is rendered as an animation.

Note that gnuplot will output a message to `STDERR` indicating how many frames
were recorded; this message is purely informative and not actually an error.

The following examples illustrate how to create and display animations, in this case with a
background image:
```{julia}
frames = 75 # number of animation frames
# new, empty figure
f = Figure()
# create a background curve that is shown in all frames
x_bckgnd = range(-1, 1, 200)  # x values for the background image
bckgnd = Gaston.Plot(x_bckgnd, sin.(2π*2*x_bckgnd), "lc 'black'")  # background curve
# generate all frames
x = range(-1, 1, frames)
for i in 1:frames
    plot(f[i], x[i], sin(2π*2*x[i]), "w p lc 'orange' pt 7 ps 7") # first plot the function...
    push!(f(i), bckgnd)  # ... then add the background
end
for i in frames:-1:1  # in reverse
    plot(f[2frames-i+1], x[i], sin(2π*2*x[i]), "w p lc 'orange' pt 7 ps 7")
    push!(f(2frames-i+1), bckgnd)
end
save(f, filename = "2DAnim.webp", term = "webp animate loop 0 size 640,480")
```
![](2DAnim.webp)

A difficulty arises when mixing plot formats in a notbook (say, `png` and
`gif`): the terminal is specified in the configuration variable `Gaston.config.term`.
However, some notebook programs (such as Pluto) execute cells in arbitrary
order. This means that changing the terminal in one cell may affect other
cells.

To solve this problem, Gaston provides a way to ignore the global terminal
configuration when rendering a plot. A figure `f` can be rendered with a given
terminal by calling `animate(f, term)`. The default value of `term` is stored
in `Gaston.config.altterm` and defaults to `gif animate loop 0`. Examples are
provided in these [interactive Pluto
notebooks](https://github.com/mbaz/Gaston.jl/tree/master/notebooks).

## Themes

Gaston includes several themes for common plot styles. The easiest way to use
them is through the specialized plot commands described below. For more
details, see the [Manual](@ref).

Themes are divided into _settings themes_, which specify gnuplot `set` commands,
and _plotline themes_, which specify how a particular curve is displayed
(color, thickness, etc.) Settings themes are stored in the dictionary
`Gaston.sthemes`, and plotline themes are stored in `Gaston.pthemes`. The
themed commands described below use combinations of these themes to create a
specific type of plot.

In gnuplot, plotlines (as in `plot with lines`) are especially difficult to
theme, because repeated options are errors, and options given in the wrong
order may also cause errors. As an example, consider using `scatter` to plot
some points; we want to use `pointtype` number 4:
```julia
scatter(rand(10), rand(10), "pointtype = 4")
```
This command causes an error because the plotline theme `:scatter` already
specifies the pointtype! To plot a scatter plot using the desired point type,
use plain `plot` with the appropriate settings, create your own theme, or
modify the built-in theme. Here is an example where the theme is modified.
First find out how the theme is set up:
```{julia}
Gaston.pthemes[:scatter]
```
Then, modify the entry for the pointtype:
```{julia}
Gaston.pthemes[:scatter][2] = "pointtype" => 4
scatter("set title 'Scatter plot with modified theme", rand(10), rand(10), "lc 'dark-green'")
```
Note how the linecolor was specified without causing an error, since it is not included in the theme.

#### Scatter plots

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`scatter` | none | `:scatter` |
|`scatter3` | `:scatter3` | `:scatter` |

```{julia}
# reset theme #| hide_line
@gpkw Gaston.pthemes[:scatter] = {with = "points", pointtype = :fcircle, pointsize = 1.5} #| hide_line
xg = randn(20)
yg = randn(20)
scatter("set title 'Scatter plot'
         set key outside",
        xg, yg,
        "title 'gaussian'")
xu = rand(20)
yu = rand(20)
scatter!(xu, yu, "title 'uniform'")
```
A 3-D scatter plot (the default settings theme (`:scatter3`) draws all the borders):
```{julia}
scatter3("set title 'A 3-D scatter plot", randn(10), randn(10), randn(10))
```

#### Stem plots

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`stem` | none | `:stem`, `:impulses` |

Stem plots are often used in digital signal processing applications to represent
a discrete-time (sampled) signal.
```{julia}
stem("set title 'Stem plot'", g)
```
To generate a stem plot, gnuplot actually plots twice: once with style `impulses` and once with
`points` (set to empty circles). Normally, each of these plots would have a different color. To
use the same color for both, use the `color` keyword argument:
```{julia}
stem("set title 'Stem plot'", g, color = "'goldenrod'")
```
The circular marks can be omitted with the `onlyimpulses` keyword argument:
```{julia}
stem("set title 'Stem plot with onlyimpulses'", g, onlyimpulses = true)
```

#### Bar plots

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`bar` | `:boxplot` | `:box` |
|`barerror` | `:boxerror` | `:box` |

```{julia}
bar("set title 'Bar plot'", rand(10), "lc 'turquoise'")
```
This example shows how to plot two sets of bars, using `bar!`:
```{julia}
bar("set title 'Two bar plots'", rand(10), "lc 'dark-violet'")
bar!(1.5:10.5, 0.5*rand(10), "lc 'plum' fill pattern 4")
```
Error bars are handled by `barerror`; there is also `barerror!`.
```{julia}
barerror("set title 'Error bars plot'", 1:10, rand(10), 0.1*rand(10).+0.1, "lc 'sandybrown'")
```

#### Histograms

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`histogram` | `:histplot` | `:box`, `:horhist` (1-D); `:image`  (2-D) |

The `histogram` function takes these optional keyword arguments:
* `nbins`: specifies the number of bins. Defaults to 10.
* `mode::Symbol`: Controls histogram normalization mode; passed to
  [`StatsBase.normalize`](https://juliastats.org/StatsBase.jl/stable/empirical/#LinearAlgebra.normalize).
  Defaults to `:none`.
* `edges`: a vector or a range specifying the bin edges; if specified, takes
  precedence over `nbins`. Defaults to `nothing`.
* `horizontal::Bool`: if `true`, the histogram is drawn horizontally. Defaults
  to `false`.
`histogram` uses the settings theme `:histplot`, and plotline themes `:box` or `:horhist`.
2-D histograms are supported, by passing two datasets.

Using `nbins`:
```{julia}
histogram("set title 'Histogram (nbins)'",
          randn(10_000),
          nbins = 20, mode = :pdf)
```

Using `edges`:
```{julia}
histogram("set title 'Histogram (edges)'",
          0.75*randn(10_000),
          edges = -2:0.75:3, "lc 'dark-khaki'")
```

A horizontal histogram:
```{julia}
histogram("set title 'horizontal histogram'",
          rand(1000),
          nbins = 15, horizontal = true, "lc 'orchid'")
```

In the case of 2-D histograms, `nbins` or `egdes` may be a tuple; otherwise, both axes use the
same settings. The plotline theme is `:image`.
```{julia}
x = 2.5*randn(100_000)
y = 2.5*randn(100_000)
th = @gpkw {palette = :matter, colorbox = false, title = Q"2-D histogram",
            xrange = (-10, 10), yrange = (-10, 10)}
histogram(th, x, y, nbins = 50, mode = :pdf)
```

#### Images

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`imagesc` | `:imagesc` | `:image`, `:rgbimage` |

Arrays may be plotted as images using `imagesc`. Note that, in contrast to other plotting packages,
the first data row is plotted horizontally and at the top.
```{julia}
X = [0 1 2 3;
     0 3 2 1;
     0 2 2 0;
     3 0 0 0]
imagesc("unset xtics", "unset ytics", X)
```
To display the image as grayscale, use the `gray` palette.
```{julia}
using Images, TestImages
img = testimage("lake_gray");
ii = channelview(img)[1,:,:].*255;
@gpkw imagesc({palette = :gray}, ii)
```
An RGB image is a plot of a 3-D array, where  `[1,;,:]`
is the red channel, `[2,:,:]` is the green channel, and
`[3,:,:]` is the blue channels.
```{julia}
img = testimage("lake_color")
@gpkw imagesc({size = "square", autoscale = "fix"}, channelview(img).*255)
```

#### Surfaces

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`wireframe` | `:hidden3d` | none |
|`surf` | `:hidden3d` | `:pm3d` |

A surface can be plotted as a "wireframe" (or a "mesh") with the `wireframe`
command. By default, `hidden3d` is active, so that elements behind the surface
are not plotted.
```{julia}
f1(x,y) = sin(sqrt(x*x+y*y))/sqrt(x*x+y*y)
th = @gpkw {title = Q"Sombrero Wireframe", palette = :matter}
@gpkw wireframe(th, (-15, 15, 30), f1)
```
Solid surfaces are plotted with `surf`:
```{julia}
th = @gpkw {title = Q"Sombrero Surface", palette = :matter}
@gpkw surf(th, (-15, 15, 200), f1)
```
When plotting a function and a single range (such as `(-15, 15, 200)` above) is given, it is used for
both `x` and `y` coordinates. Two ranges may be given as well to control the `x` and `y` ranges
separately:
```{julia}
@gpkw surf(th, (-15, 15, 200), (-25, 5, 200), f1)
```

#### Contour plots

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`contour` | `:contour` | `:labels` |
| `surfcountour` | `:contourproj` | `:labels` |

By default, contour plots include numerical labels:
```{julia}
f2(x,y) = cos(x/2)*sin(y/2)
contour("set title 'Contour Plot'", (-10, 10, 50), f2)
```
To plot contours without labels, use the keyword argument `labels = false`:
```{julia}
contour("set title 'Contour Plot Without Labels'", (-10, 10, 50), f2, labels = false)
```
It's possible to plot a wireframe surface and a contour projected on the base of the plot
using `surfcountour`:
```{julia}
surfcontour("set title 'Surface With Projected Contours'", (-5, 5, 40), f2, "lc 'orange'")
```
The same plot without contour labels:
```{julia}
surfcontour("set title 'Surface With Contours, No Labels'",
            (-5, 5, 40), f2, "lc 'orange'", labels = false)
```

#### Heatmap plots

| command | settings theme | plotline theme |
|:--------|:---------------|:---------------|
|`heatmap` | `:heatmap` | `:pm3d` |

```{julia}
theme = @gpkw {palette = :matter, title = Q"Heatmap"}
heatmap(theme, :notics, :nocb, :labels, (-10, 10, 70), f2)
```

##### Contour lines on heatmap

It is possible to include contour lines in a heatmap plot. The following example is
taken from [this gnuplot blog post]
(https://gnuplot-tricks.blogspot.com/2009/07/maps-contour-plots-with-labels.html).
The function `Gaston.plotwithtable` returns a `Gaston.DataTable`, which wraps
`IOBuffer`. It can be used as an argument to `plot`.
```{julia}
# define function to plot
x = y = range(-5, 5, 100)
f4(x,y) = sin(1.3*x)*cos(0.9*y)+cos(.8*x)*sin(1.9*y)+cos(y*.2*x)

# obtain function contours using 'plot with table'
settings = """set contour base
              set cntrparam level incremental -3, 0.5, 3
              unset surface"""
contours = Gaston.plotwithtable(settings, x, y, f4)

# calculate meshgrid for heatmap plot
z = Gaston.meshgrid(x, y, f4)

# plot heatmap and contours
plot("""unset key
        unset colorbox
        set palette rgbformulae 33,13,10""",
        x, y, z, "with image")
plot!(contours, "w l lw 1.5 lc 'slategray'")
```


